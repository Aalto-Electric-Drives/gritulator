:py:mod:`control.sm.vector`
===========================

.. py:module:: control.sm.vector

.. autoapi-nested-parse::

   This module contains vector control for PMSM drives.



Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   control.sm.vector.VectorCtrl
   control.sm.vector.CurrentCtrl
   control.sm.vector.CurrentRef
   control.sm.vector.SensorlessObserver




.. py:class:: VectorCtrl(pars, speed_ctrl, current_ref, current_ctrl, observer)

   This class interconnects the subsystems of the PMSM control system and
   provides the interface to the solver.


   .. py:method:: __call__(self, w_m_ref, i_s_abc, u_dc, *args)

      Main control loop.

      :param w_m_ref: Rotor speed reference (in electrical rad/s).
      :type w_m_ref: float
      :param i_s_abc: Phase currents.
      :type i_s_abc: ndarray, shape (3,)
      :param u_dc: DC-bus voltage.
      :type u_dc: float
      :param w_M: Rotor speed (in mechanical rad/s), for the sensored control.
      :type w_M: float, optional
      :param theta_M: Rotor angle (in mechanical rad), for the sensored control.
      :type theta_M: float, optional

      :returns: * **d_abc_ref** (*ndarray, shape (3,)*) -- Duty ratio references.
                * **T_s** (*float*) -- Sampling period.


   .. py:method:: __str__(self)

      Return str(self).



.. py:class:: CurrentCtrl(pars)

   A current controller corresponding to the paper "Flux-linkage-based current
   control of saturated synchronous motors":

       https://doi.org/10.1109/TIA.2019.291925

   The continuous-time complex-vector design corresponding to (13) is used
   here. This design could be equivalently presented as a 2DOF PI controller.
   For better performance at high speeds with low sampling frequencies, the
   discrete-time design in (18) is recommended.


   .. py:method:: output(self, i_s_ref, i_s)

      Compute the unlimited voltage reference.

      :param i_s_ref: Current reference.
      :type i_s_ref: complex
      :param i_s: Measured current.
      :type i_s: complex

      :returns: * **u_s_ref** (*complex*) -- Unlimited voltage reference.
                * **e** (*complex*) -- Error signal (scaled, corresponds to the stator flux linkage).


   .. py:method:: update(self, e, u_s_ref, u_s_ref_lim, w_m)

      Updates the integral state.

      :param e: Error signal (scaled, corresponds to the stator flux linkage).
      :type e: complex
      :param u_s_ref: Unlimited voltage reference.
      :type u_s_ref: complex
      :param u_s_ref_lim: Limited voltage reference.
      :type u_s_ref_lim: complex
      :param w_m: Angular rotor speed.
      :type w_m: float


   .. py:method:: __str__(self)

      Return str(self).



.. py:class:: CurrentRef(pars)

   This reference calculation method resembles the method presented in
   "Analytical design and autotuning of adaptive flux-weakening voltage
   regulation loop in IPMSM drives with accurate torque regulation":

       https://doi.org/10.1109/TIA.2019.2942807

   Instead of the PI controller, we use a simpler integral controller with a
   constant gain. The resulting operating-point-dependent closed-loop pole
   could be derived using (12) of the paper. The MTPV limit is also included
   by means of limiting the reference torque and the d-axis current reference.


   .. py:method:: output(self, tau_M_ref, w_m, u_dc)

      Compute the stator current reference.

      :param tau_M_ref: Torque reference.
      :type tau_M_ref: float
      :param w_m: Rotor speed (in electrical rad/s)
      :type w_m: float
      :param u_dc: DC-bus voltage.
      :type u_dc: float

      :returns: * **i_s_ref** (*complex*) -- Stator current reference.
                * **tau_M** (*float*) -- Limited torque reference.


   .. py:method:: update(self, tau_M, u_s_ref, u_dc)

      Field-weakening based on the unlimited reference voltage.

      :param tau_M: Limited torque reference.
      :type tau_M: float
      :param u_s_ref: Unlimited stator voltage reference.
      :type u_s_ref: complex
      :param u_dc: float.
      :type u_dc: DC-bus voltage.


   .. py:method:: __str__(self)

      Return str(self).



.. py:class:: SensorlessObserver(pars)

   A sensorless observer corresponding to the paper "Observers for sensorless
   synchronous motor drives: Framework for design and analysis":

       https://doi.org/10.1109/TIA.2018.2858753

   The observer gain decouples the electrical and mechanical dynamicas and
   allows placing the poles of the corresponding linearized estimation
   error dynamics.


   .. py:method:: update(self, u_s, i_s)

      Update the states for the next sampling period.

      :param u_s: Stator voltage in estimated rotor coordinates.
      :type u_s: complex
      :param i_s: Stator current in estimated rotor coordinates.
      :type i_s: complex


   .. py:method:: __str__(self)

      Return str(self).



