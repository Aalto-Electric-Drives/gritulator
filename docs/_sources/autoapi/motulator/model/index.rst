:py:mod:`motulator.model`
=========================

.. py:module:: motulator.model

.. autoapi-nested-parse::

   
   Continuous-time system models.
















   ..
       !! processed by numpydoc !!


Subpackages
-----------
.. toctree::
   :titlesonly:
   :maxdepth: 3

   ac_grid/index.rst
   dc_bus/index.rst


Package Contents
----------------

Classes
~~~~~~~

.. autoapisummary::

   motulator.model.StiffSource
   motulator.model.FlexSource
   motulator.model.LFilter
   motulator.model.LCLFilter
   motulator.model.FrequencyConverter
   motulator.model.Inverter
   motulator.model.CarrierComparison
   motulator.model.Simulation




.. py:class:: StiffSource(w_N=2 * np.pi * 50, e_g_abs=lambda t: 400 * np.sqrt(2 / 3))


   
   Grid subsystem.

   This model is a constant frequency 3-phase voltage source of the AC grid.

   :param w_N: grid constant frequency
   :type w_N: float
   :param e_g_abs: 3-phase grid voltage magnitude (phase-to-ground peak value)
   :type e_g_abs: function















   ..
       !! processed by numpydoc !!
   .. py:method:: voltages(t)

      
      Compute the grid voltage in stationary frame:

      :param t: Time.
      :type t: float

      :returns: **e_gs** -- grid complex voltage.
      :rtype: complex















      ..
          !! processed by numpydoc !!

   .. py:method:: meas_voltages(t)

      
      Measure the phase voltages at the end of the sampling period.

      :param t: Time.
      :type t: float

      :returns: **e_g_abc** -- Phase voltages.
      :rtype: 3-tuple of floats















      ..
          !! processed by numpydoc !!


.. py:class:: FlexSource(T_D=10, T_N=3, H_g=3, D_g=0, r_d=0.05, T_gov=0.5, w_N=2 * np.pi * 50, S_grid=500000000.0, e_g_abs=lambda t: 400 * np.sqrt(2 / 3), p_m_ref=lambda t: 0, p_e=lambda t: 0)


   
   Grid subsystem.
   This models the 3-phase voltage source of the AC grid while taking into
   account the electromechanical dynamics of a typical grid generated by the
   synchronous generators.

   More information about the model can be found in [1].

   [1] : ENTSO-E, Documentation on Controller Tests in Test Grid
   Configurations, Technical Report, 26.11.2013.
   :param T_D: turbine delay time constant (in seconds).
   :type T_D: float
   :param T_N: turbine derivative time constant (in seconds).
   :type T_N: float
   :param H_g: grid inertia constant (in seconds).
   :type H_g: float
   :param r_d: primary frequency droop control gain (in p.u.).
   :type r_d: float
   :param T_gov: governor time constant (in seconds).
   :type T_gov: float
   :param w_N: grid constant frequency (in rad/s).
   :type w_N: float
   :param S_grid: grid rated power (in VA).
   :type S_grid: float
   :param e_g_abs: 3-phase grid voltage magnitude (phase-to-ground peak value).
   :type e_g_abs: function
   :param p_m_ref: mechanical power output reference (in W).
   :type p_m_ref: function
   :param p_e: electrical power disturbance (in W).
   :type p_e: function















   ..
       !! processed by numpydoc !!
   .. py:method:: f(t, err_w_g, p_gov, x_turb)

      
      Compute the state derivative.
      :param t: Time.
      :type t: float
      :param err_w_g: grid angular speed deviation (in mechanical rad/s).
      :type err_w_g: float
      :param p_gov: governor output power (in W).
      :type p_gov: float
      :param x_turb: turbine state variable (in W).
      :type x_turb: float
      :param p_e: electrical power disturbance (in W).
      :type p_e: float

      :returns: Time derivative of the state vector.
      :rtype: list, length 2















      ..
          !! processed by numpydoc !!

   .. py:method:: voltages(t, theta_g)

      
      Compute the grid voltage in stationary frame:

      :param t: Time.
      :type t: float
      :param theta_g: grid electrical angle (in rad).
      :type theta_g: float

      :returns: **e_gs** -- grid complex voltage (in V).
      :rtype: complex















      ..
          !! processed by numpydoc !!

   .. py:method:: meas_voltages(t)

      
      Measure the phase voltages at the end of the sampling period.

      :returns: **e_g_abc** -- Phase voltages.
      :rtype: 3-tuple of floats















      ..
          !! processed by numpydoc !!

   .. py:method:: meas_freq()

      
      Measure the grid frequency.
      This returns the grid frequency at the end of the sampling period.
      :returns: **w_g0** -- Grid angular speed (in rad/s).
      :rtype: float
















      ..
          !! processed by numpydoc !!

   .. py:method:: meas_angle()

      
      Measure the grid angle.
      This returns the grid angle at the end of the sampling period.
      :returns: **theta_g0** -- grid electrical angle (in rad).
      :rtype: float
















      ..
          !! processed by numpydoc !!


.. py:class:: LFilter(U_gN=400 * np.sqrt(2 / 3), L_f=0.006, R_f=0, L_g=0, R_g=0)


   
   Inductive filter model with a connection made to the inverter outputs.

   An inductive filter model is built using a simple inductance model where
   the two output voltages are imposed and the current can be calculated using
   dynamic equations. This model includes a model for an inductive-resistive
   impedance of the grid combined with the L-filter model.

   :param L_f: Filter inductance (in H)
   :type L_f: float
   :param R_f: Filter resistance (in Ohm)
   :type R_f: float
   :param L_g: Grid inductance (in H)
   :type L_g: float
   :param R_g: Grid resistance (in Ohm)
   :type R_g: float















   ..
       !! processed by numpydoc !!
   .. py:method:: pcc_voltages(i_gs, u_cs, e_gs)

      
      Compute the PCC voltage, located in-between the filter and the line
      impedances

      :param i_gs: Line current (A).
      :type i_gs: complex
      :param u_cs: Converter voltage (V).
      :type u_cs: complex
      :param e_gs: Grid voltage (V).
      :type e_gs: complex

      :returns: **u_gs** -- Voltage at the point of common coupling (PCC).
      :rtype: complex















      ..
          !! processed by numpydoc !!

   .. py:method:: f(i_gs, u_cs, e_gs)

      
      Compute the state derivatives.

      :param i_gs: Line current (A).
      :type i_gs: complex
      :param u_cs: Converter-side voltage (V).
      :type u_cs: complex
      :param e_gs: Grid-side voltage (V).
      :type e_gs: complex

      :returns: **di_gs** -- Time derivative of the complex state i_gs (line current, in A)
      :rtype: complex















      ..
          !! processed by numpydoc !!

   .. py:method:: meas_currents()

      
      Measure the phase currents at the end of the sampling period.

      :returns: **i_g_abc** -- Phase currents.
      :rtype: 3-tuple of floats















      ..
          !! processed by numpydoc !!

   .. py:method:: meas_pcc_voltage()

      
      Measure the PCC voltages at the end of the sampling period.

      :returns: **u_g_abc** -- Phase voltage at the point of common coupling (PCC).
      :rtype: 3-tuple of floats















      ..
          !! processed by numpydoc !!


.. py:class:: LCLFilter(U_gN=400 * np.sqrt(2 / 3), L_fc=0.006, R_fc=0, L_fg=0.003, R_fg=0, C_f=1e-05, G_f=0, L_g=0, R_g=0)


   
   LCL filter and inductive grid model with a connection made to the
   inverter outputs.

   An LCL-type grid model is built using an LCL model where the two output
   voltages are imposed and the grid-side current, the converter-side
   current and the capacitance voltage can be calculated using dynamic
   equations. This model includes a model for an inductive-resistive
   impedance of the grid combined with the LCL-filter model.

   :param L_fc: Converter-side filter inductance (in H)
   :type L_fc: float
   :param R_fc: Converter-side filter resistance (in Ohm)
   :type R_fc: float
   :param L_fg: Grid-side filter inductance (in H)
   :type L_fg: float
   :param R_fg: Grid-side filter resistance (in Ohm)
   :type R_fg: float
   :param C_f: Filter capacitance (in F)
   :type C_f: float
   :param G_f: LCL filter conductance (in S)
   :type G_f: float
   :param L_g: Grid inductance (in H)
   :type L_g: float
   :param R_g: Grid resistance (in Ohm)
   :type R_g: float















   ..
       !! processed by numpydoc !!
   .. py:method:: pcc_voltages(i_gs, u_fs, e_gs)

      
      Compute the PCC voltage, located in-between the filter and the line
      impedances

      :param i_gs: Grid-side line current (A).
      :type i_gs: complex
      :param u_fs: Capacitance voltage (V).
      :type u_fs: complex
      :param e_gs: Grid-side voltage (V).
      :type e_gs: complex

      :returns: **u_gs** -- Voltage at the point of common coupling (PCC).
      :rtype: complex















      ..
          !! processed by numpydoc !!

   .. py:method:: f(i_cs, u_fs, i_gs, u_cs, e_gs)

      
      Compute the state derivatives.

      :param i_cs: Converter line current (A).
      :type i_cs: complex
      :param u_fs: Capacitance voltage (V).
      :type u_fs: complex
      :param i_gs: Grid line current (A).
      :type i_gs: complex
      :param u_cs: Converter voltage (V).
      :type u_cs: complex
      :param e_gs: Grid voltage (V).
      :type e_gs: complex

      :returns: * **i_cs** (*complex*) -- Time derivative of the complex i_cs (in A).
                * **u_fs** (*complex*) -- Time derivative of the complex u_fs (in V).
                * **di_gs** (*complex*) -- Time derivative of the complex state i_gs (in A)















      ..
          !! processed by numpydoc !!

   .. py:method:: meas_currents()

      
      Measure the converter currents at the end of the sampling period.

      :returns: **i_c_abc** -- Phase currents.
      :rtype: 3-tuple of floats















      ..
          !! processed by numpydoc !!

   .. py:method:: meas_grid_currents()

      
      Measure the grid currents at the end of the sampling period.

      :returns: **i_g_abc** -- Phase currents.
      :rtype: 3-tuple of floats















      ..
          !! processed by numpydoc !!

   .. py:method:: meas_cap_voltage()

      
      Measure the capacitor voltages at the end of the sampling period.

      :returns: **u_f_abc** -- Phase voltage through the capacitance of the LCL filter.
      :rtype: 3-tuple of floats















      ..
          !! processed by numpydoc !!

   .. py:method:: meas_pcc_voltage()

      
      Measure the PCC voltages at the end of the sampling period.

      :returns: **u_g_abc** -- Phase voltage at the point of common coupling (PCC).
      :rtype: 3-tuple of floats















      ..
          !! processed by numpydoc !!


.. py:class:: FrequencyConverter(L, C, U_g, f_g)


   Bases: :py:obj:`Inverter`

   
   Frequency converter.

   This extends the Inverter class with models for a strong grid, a
   three-phase diode-bridge rectifier, an LC filter, and a three-phase
   inverter.

   :param L: DC-bus inductance (H).
   :type L: float
   :param C: DC-bus capacitance (F).
   :type C: float
   :param U_g: Grid voltage (V, line-line, rms).
   :type U_g: float
   :param f_g: Grid frequency (Hz).
   :type f_g: float















   ..
       !! processed by numpydoc !!
   .. py:method:: grid_voltages(t)

      
      Compute three-phase grid voltages.

      :param t: Time (s).
      :type t: float

      :returns: **u_g_abc** -- Phase voltages (V).
      :rtype: ndarray of floats, shape (3,)















      ..
          !! processed by numpydoc !!

   .. py:method:: f(t, u_dc, i_L, i_dc)

      
      Compute the state derivatives.

      :param t: Time (s).
      :type t: float
      :param u_dc: DC-bus voltage (V) over the capacitor.
      :type u_dc: float
      :param i_L: DC-bus inductor current (A).
      :type i_L: float
      :param i_dc: Current to the inverter (A).
      :type i_dc: float

      :returns: Time derivative of the state vector, [du_dc, di_L]
      :rtype: list, length 2















      ..
          !! processed by numpydoc !!


.. py:class:: Inverter(u_dc)


   
   Inverter with constant DC-bus voltage and switching-cycle averaging.

   :param u_dc: DC-bus voltage (V).
   :type u_dc: float















   ..
       !! processed by numpydoc !!
   .. py:method:: ac_voltage(q, u_dc)
      :staticmethod:

      
      Compute the AC-side voltage of a lossless inverter.

      :param q: Switching state vector.
      :type q: complex
      :param u_dc: DC-bus voltage (V).
      :type u_dc: float

      :returns: **u_ac** -- AC-side voltage (V).
      :rtype: complex















      ..
          !! processed by numpydoc !!

   .. py:method:: dc_current(q, i_ac)
      :staticmethod:

      
      Compute the DC-side current of a lossless inverter.

      :param q: Switching state vector.
      :type q: complex
      :param i_ac: AC-side current (A).
      :type i_ac: complex

      :returns: **i_dc** -- DC-side current (A).
      :rtype: float















      ..
          !! processed by numpydoc !!

   .. py:method:: meas_dc_voltage()

      
      Measure the DC-bus voltage.

      :returns: DC-bus voltage (V).
      :rtype: float















      ..
          !! processed by numpydoc !!


.. py:class:: CarrierComparison(N=2**12, return_complex=True)


   
   Carrier comparison.

   This computes the the switching states and their durations based on the
   duty ratios. Instead of searching for zero crossings, the switching
   instants are explicitly computed in the beginning of each sampling period,
   allowing faster simulations.

   :param N: Amount of the counter quantization levels. The default is 2**12.
   :type N: int, optional
   :param return_complex: Complex switching state space vectors are returned if True. Otherwise
                          phase switching states are returned. The default is True.
   :type return_complex: bool, optional

   .. rubric:: Examples

   >>> from motulator.model import CarrierComparison
   >>> carrier_cmp = CarrierComparison(return_complex=False)
   >>> # First call gives rising edges
   >>> t_steps, q_abc = carrier_cmp(1e-3, [.4, .2, .8])
   >>> # Durations of the switching states
   >>> t_steps
   array([0.00019995, 0.00040015, 0.00019995, 0.00019995])
   >>> # Switching states
   >>> q_abc
   array([[0, 0, 0],
          [0, 0, 1],
          [1, 0, 1],
          [1, 1, 1]])
   >>> # Second call gives falling edges
   >>> t_steps, q_abc = carrier_cmp(.001, [.4, .2, .8])
   >>> t_steps
   array([0.00019995, 0.00019995, 0.00040015, 0.00019995])
   >>> q_abc
   array([[1, 1, 1],
          [1, 0, 1],
          [0, 0, 1],
          [0, 0, 0]])
   >>> # Sum of the step times equals T_s
   >>> np.sum(t_steps)
   0.001
   >>> # 50% duty ratios in all phases
   >>> t_steps, q_abc = carrier_cmp(1e-3, [.5, .5, .5])
   >>> t_steps
   array([0.0005, 0.    , 0.    , 0.0005])
   >>> q_abc
   array([[0, 0, 0],
          [0, 0, 0],
          [0, 0, 0],
          [1, 1, 1]])















   ..
       !! processed by numpydoc !!

.. py:class:: Simulation(mdl=None, ctrl=None, delay=1, pwm=False)


   
   Simulation environment.

   Each simulation object has a system model object and a controller object.

   :param mdl: Continuous-time system model.
   :type mdl: Drive
   :param ctrl: Discrete-time controller.
   :type ctrl: Ctrl
   :param delay: Amount of computational delays. The default is 1.
   :type delay: int, optional
   :param pwm: Enable carrier comparison. The default is False.
   :type pwm: bool, optional















   ..
       !! processed by numpydoc !!
   .. py:method:: simulate(t_stop=1, max_step=np.inf)

      
      Solve the continuous-time model and call the discrete-time controller.

      :param t_stop: Simulation stop time. The default is 1.
      :type t_stop: float, optional
      :param max_step: Max step size of the solver. The default is inf.
      :type max_step: float, optional

      .. rubric:: Notes

      Other options of `solve_ivp` could be easily changed if needed, but, for
      simplicity, only `max_step` is included as an option of this method.















      ..
          !! processed by numpydoc !!

   .. py:method:: save_mat(name='sim')

      
      Save the simulation data into MATLAB .mat files.

      :param name: Name for the simulation instance. The default is `sim`.
      :type name: str, optional















      ..
          !! processed by numpydoc !!


